import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { logger } from '../utils/index.js';
const sass = await import('sass-embedded')
    .catch(() => import('sass'))
    .catch(() => {
    throw new Error('The Sass package is not installed. You can do this with `npm i -D sass-embedded`');
});
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export class JitEngine {
    utils = new Set();
    breakpoints = [];
    breakpointsMap = {};
    inputFileDir = __dirname;
    sassModuleName = 'tools';
    inputFileCache = '@use "../sass/tools";';
    defaultSassConfig = '@use "sass:map";\n @use "../sass/tools/settings" as ml;';
    utilsByFile = new Map();
    utilsRegexps = {
        quotedContent: /"\n?[^"]*[^"\n]*\n?"/g,
        singleQuotedContent: /'\n?[^']*[^'\n]*\n?'/g,
        backtickQuotedContent: /`\n?[^`]*[^`\n]*\n?`/g,
        tooMoreSpaces: /\s{2,}|\n/g,
        escapedQuotes: /\\['"`]/g,
        utilName: /^-?[A-Z]{1}[a-zA-Z]*/,
        uppercaseLetter: /[A-Z]/,
        contextUtil: /-Ctx([\d\-#]|$)/,
        valueSeparator: /[0-9-#=]/,
    };
    configRegexps = {
        userSettings: /@use ['"][^'"]*(tools|mlut|core)['"](\s*as\s+[\w]+)?\s+with\s*\(([^;]+)\);/s,
        sassModuleName: /@use ['"][^'"]*(tools|mlut|core)['"]\s*;/s,
    };
    async init([inputPath, inputContent] = ['', '']) {
        if (this.utils.size) {
            return;
        }
        let sassConfig = this.defaultSassConfig;
        if (inputPath && inputContent) {
            this.inputFileDir = path.dirname(path.resolve(process.cwd(), inputPath));
            this.inputFileCache = inputContent;
            sassConfig = this.extractUserSassConfig(inputContent);
        }
        await this.loadUtils(sassConfig);
    }
    putContent(id, content) {
        if (!content) {
            return;
        }
        this.utilsByFile.set(id, this.extractUtils(content));
    }
    deleteContent(id) {
        return this.utilsByFile.delete(id);
    }
    async updateSassConfig(content) {
        this.inputFileCache = content;
        const sassConfig = this.extractUserSassConfig(content);
        if (sassConfig) {
            await this.loadUtils(sassConfig);
        }
    }
    async generateCss() {
        if (this.utils.size === 0) {
            logger.warn('Config with utilities is not loaded!');
            return '';
        }
        if (this.utilsByFile.size === 0) {
            logger.warn('No content to generate CSS was found!');
            return '';
        }
        const allUniqueUtils = [...new Set([...this.utilsByFile.values()].flat())];
        const applyStr = `\n@include ${this.sassModuleName}.apply(${JSON.stringify(allUniqueUtils)},(),true);`;
        return sass.compileStringAsync(this.inputFileCache + applyStr, { loadPaths: [this.inputFileDir, 'node_modules'] }).then(({ css }) => css, (e) => (logger.error('Sass compilation error.', e), ''));
    }
    extractUtils(content) {
        let fixedContent = content.replace(this.utilsRegexps.escapedQuotes, '');
        const allClassNames = fixedContent
            .match(this.utilsRegexps.quotedContent)
            ?.reduce(this.filterAndProcessClassStr, []) ?? [];
        fixedContent = fixedContent.replace(this.utilsRegexps.quotedContent, '');
        fixedContent
            .match(this.utilsRegexps.singleQuotedContent)
            ?.reduce(this.filterAndProcessClassStr, allClassNames);
        fixedContent
            .replace(this.utilsRegexps.singleQuotedContent, '')
            .match(this.utilsRegexps.backtickQuotedContent)
            ?.reduce(this.filterAndProcessClassStr, allClassNames);
        const utilsWithAtRule = new Set();
        const mainUtils = [...allClassNames.join(' ').split(' ').reduce((acc, cssClass) => {
                const utilComponents = cssClass.split('_');
                const utility = utilComponents.find((str) => (this.utilsRegexps.utilName.test(str)));
                if (utility) {
                    const separator = utility.replace(this.utilsRegexps.utilName, '')[0];
                    if (separator && !this.utilsRegexps.valueSeparator.test(separator)) {
                        return acc;
                    }
                    const utilName = utility.match(this.utilsRegexps.utilName)?.[0];
                    if (this.utils.has(utilName) ||
                        (utilName[0] === '-' && !this.utilsRegexps.contextUtil.test(utilName))) {
                        const [atRule] = utilComponents;
                        if (utilComponents.length > 1 && !atRule.startsWith(utilName) && (atRule[0] === '@' ||
                            atRule[0] === '<' ||
                            (atRule in this.breakpointsMap) ||
                            this.breakpoints.find((item) => atRule.startsWith(item)))) {
                            utilsWithAtRule.add(cssClass);
                        }
                        else {
                            acc.add(cssClass);
                        }
                    }
                }
                return acc;
            }, new Set())];
        return mainUtils.concat([...utilsWithAtRule].sort(this.compareUtilsWithAtRule));
    }
    compareUtilsWithAtRule = (a, b) => {
        if (a[0] === '@' && b[0] === '@') {
            return 0;
        }
        if (a[0] === '@') {
            return 1;
        }
        if (b[0] === '@') {
            return -1;
        }
        const bpA = a.split('_')[0];
        const bpB = b.split('_')[0];
        if (!(bpA in this.breakpointsMap)) {
            return 1;
        }
        if (!(bpB in this.breakpointsMap)) {
            return -1;
        }
        return this.breakpointsMap[bpA] - this.breakpointsMap[bpB];
    };
    filterAndProcessClassStr = (acc, str) => {
        if (this.utilsRegexps.uppercaseLetter.test(str)) {
            acc.push(str.replace(this.utilsRegexps.tooMoreSpaces, ' ').slice(1, -1));
        }
        return acc;
    };
    extractUserSassConfig(content) {
        let matchResult = content.match(this.configRegexps.userSettings);
        if (matchResult != null) {
            const userSettings = matchResult.at(-1);
            this.sassModuleName = matchResult[2] ?
                matchResult[2].replace(/\s*as\s*/, '') :
                matchResult[1];
            return this.defaultSassConfig.slice(0, -1) + ` with (${userSettings});`;
        }
        matchResult = content.match(this.configRegexps.sassModuleName);
        if (matchResult != null) {
            this.sassModuleName = matchResult[1];
        }
    }
    async loadUtils(userConfig = this.defaultSassConfig) {
        const placeholderRules = `
			\n a{ all: map.keys(map.get(ml.$utils-db, "utils", "registry")); }
			\n b{ all: map.keys(map.get(ml.$at-rules-cfg, "breakpoints")); }
		`;
        const { css } = (await sass.compileStringAsync(userConfig + placeholderRules, {
            style: 'compressed',
            loadPaths: [__dirname, 'node_modules'],
        }));
        const [, rawUtils, rawBreakpoints] = css.split('all:');
        const rawUtilsStrEnd = rawUtils.lastIndexOf('"') - rawUtils.length + 1;
        const rawBpsStrEnd = rawBreakpoints.lastIndexOf('"') - rawBreakpoints.length + 1;
        this.utils = new Set(JSON.parse('[' + rawUtils.slice(0, rawUtilsStrEnd) + ']'));
        this.breakpoints =
            JSON.parse('[' + rawBreakpoints.slice(0, rawBpsStrEnd) + ']');
        this.breakpointsMap = this.breakpoints.reduce((acc, item, i) => {
            acc['<' + item] = i - 0.1;
            acc[item] = i;
            return acc;
        }, {});
    }
}
export const jitEngine = new JitEngine();
